// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: buckets.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteBucket = `-- name: DeleteBucket :exec
DELETE FROM buckets WHERE id = $1 AND user_id = $2
`

type DeleteBucketParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteBucket(ctx context.Context, arg DeleteBucketParams) error {
	_, err := q.db.Exec(ctx, deleteBucket, arg.ID, arg.UserID)
	return err
}

const getBucket = `-- name: GetBucket :one
SELECT
    b.id, b.user_id, b.credential_id, b.name, b.region, b.description, b.size_bytes, b.created_at, b.updated_at,
    c.name as credential_name,
    c.provider as credential_provider
FROM buckets b
JOIN credentials c ON c.id = b.credential_id
WHERE b.id = $1 AND b.user_id = $2
`

type GetBucketParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetBucketRow struct {
	Bucket             Bucket `json:"bucket"`
	CredentialName     string `json:"credential_name"`
	CredentialProvider string `json:"credential_provider"`
}

func (q *Queries) GetBucket(ctx context.Context, arg GetBucketParams) (GetBucketRow, error) {
	row := q.db.QueryRow(ctx, getBucket, arg.ID, arg.UserID)
	var i GetBucketRow
	err := row.Scan(
		&i.Bucket.ID,
		&i.Bucket.UserID,
		&i.Bucket.CredentialID,
		&i.Bucket.Name,
		&i.Bucket.Region,
		&i.Bucket.Description,
		&i.Bucket.SizeBytes,
		&i.Bucket.CreatedAt,
		&i.Bucket.UpdatedAt,
		&i.CredentialName,
		&i.CredentialProvider,
	)
	return i, err
}

const getBucketByName = `-- name: GetBucketByName :one
SELECT
    b.id, b.user_id, b.credential_id, b.name, b.region, b.description, b.size_bytes, b.created_at, b.updated_at,
    c.name as credential_name,
    c.provider as credential_provider
FROM buckets b
JOIN credentials c ON c.id = b.credential_id
WHERE b.user_id = $1 AND b.name = $2
`

type GetBucketByNameParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Name   string      `json:"name"`
}

type GetBucketByNameRow struct {
	Bucket             Bucket `json:"bucket"`
	CredentialName     string `json:"credential_name"`
	CredentialProvider string `json:"credential_provider"`
}

func (q *Queries) GetBucketByName(ctx context.Context, arg GetBucketByNameParams) (GetBucketByNameRow, error) {
	row := q.db.QueryRow(ctx, getBucketByName, arg.UserID, arg.Name)
	var i GetBucketByNameRow
	err := row.Scan(
		&i.Bucket.ID,
		&i.Bucket.UserID,
		&i.Bucket.CredentialID,
		&i.Bucket.Name,
		&i.Bucket.Region,
		&i.Bucket.Description,
		&i.Bucket.SizeBytes,
		&i.Bucket.CreatedAt,
		&i.Bucket.UpdatedAt,
		&i.CredentialName,
		&i.CredentialProvider,
	)
	return i, err
}

const insertBucket = `-- name: InsertBucket :one
INSERT INTO buckets (id, user_id, credential_id, name, region, description)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, credential_id, name, region, description, size_bytes, created_at, updated_at
`

type InsertBucketParams struct {
	ID           pgtype.UUID `json:"id"`
	UserID       pgtype.UUID `json:"user_id"`
	CredentialID pgtype.UUID `json:"credential_id"`
	Name         string      `json:"name"`
	Region       string      `json:"region"`
	Description  *string     `json:"description"`
}

func (q *Queries) InsertBucket(ctx context.Context, arg InsertBucketParams) (Bucket, error) {
	row := q.db.QueryRow(ctx, insertBucket,
		arg.ID,
		arg.UserID,
		arg.CredentialID,
		arg.Name,
		arg.Region,
		arg.Description,
	)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CredentialID,
		&i.Name,
		&i.Region,
		&i.Description,
		&i.SizeBytes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBuckets = `-- name: ListBuckets :many
SELECT
    b.id, b.user_id, b.credential_id, b.name, b.region, b.description, b.size_bytes, b.created_at, b.updated_at,
    c.name as credential_name,
    c.provider as credential_provider
FROM buckets b
JOIN credentials c ON c.id = b.credential_id
WHERE b.user_id = $1
ORDER BY b.created_at DESC
`

type ListBucketsRow struct {
	Bucket             Bucket `json:"bucket"`
	CredentialName     string `json:"credential_name"`
	CredentialProvider string `json:"credential_provider"`
}

func (q *Queries) ListBuckets(ctx context.Context, userID pgtype.UUID) ([]ListBucketsRow, error) {
	rows, err := q.db.Query(ctx, listBuckets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBucketsRow{}
	for rows.Next() {
		var i ListBucketsRow
		if err := rows.Scan(
			&i.Bucket.ID,
			&i.Bucket.UserID,
			&i.Bucket.CredentialID,
			&i.Bucket.Name,
			&i.Bucket.Region,
			&i.Bucket.Description,
			&i.Bucket.SizeBytes,
			&i.Bucket.CreatedAt,
			&i.Bucket.UpdatedAt,
			&i.CredentialName,
			&i.CredentialProvider,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBucket = `-- name: UpdateBucket :exec
UPDATE buckets
SET description = $3, updated_at = NOW()
WHERE id = $1 AND user_id = $2
`

type UpdateBucketParams struct {
	ID          pgtype.UUID `json:"id"`
	UserID      pgtype.UUID `json:"user_id"`
	Description *string     `json:"description"`
}

func (q *Queries) UpdateBucket(ctx context.Context, arg UpdateBucketParams) error {
	_, err := q.db.Exec(ctx, updateBucket, arg.ID, arg.UserID, arg.Description)
	return err
}

const updateBucketSize = `-- name: UpdateBucketSize :exec
UPDATE buckets
SET size_bytes = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateBucketSizeParams struct {
	ID        pgtype.UUID `json:"id"`
	SizeBytes int64       `json:"size_bytes"`
}

func (q *Queries) UpdateBucketSize(ctx context.Context, arg UpdateBucketSizeParams) error {
	_, err := q.db.Exec(ctx, updateBucketSize, arg.ID, arg.SizeBytes)
	return err
}
